---
title: "Week 6 -- Restructuring data for analysis"
---

> #### Learning objectives
>
> * Understand what makes a data set "tidy" and why you'd want your data to be structured this way
> * Use `pivot_longer()` and `pivot_wider()` operations to restructure data frames
> * Tease apart columns containing multiple variables using `separate()`
> * Modify character variables using string manipulation functions from the `stringr` package
> * Customize non-data components of plots created using ggplot2 by changing the theme

---

# Restructuring data

The data you collect or obtain from a third party is not always in a form that
is suitable for exploratory analysis and visualization and may need to be
restructured before you can fully make use of it.

This is particularly true of the plotting and summarizing tools we've been
looking at in this course which are designed specifically to work on data in a
format referred to as 'tidy' data. This is why the tidyverse is so named.

In this session, we will look at what it means for data to be 'tidy' and how
you can transform your data, if necessary, into this form. We'll also look at
useful functions for handling compound variables, that is columns that contain
more than one type of measurement or attribute (you'd be surprised how common
this is) and some of the string manipulation functions from the `stringr`
package that can help with cleaning up values within a data frame.

Finally, we'll take another look at customizing plots created with ggplot2 by
changing various non-data components that are largely cosmetic.

The functions we're mostly focusing on in this session are from the **tidyr**
and **stringr** packages both of which get loaded as part of the tidyverse.

```{r}
library(tidyverse)
```

---

# Tidy data

So what is 'tidy data' and why should we care about it?

To answer these questions, we'll look at different ways in which a simple data
set can be represented and consider the challenges associated with each. The
data set in question is a subset of data from the World Health Organization
[Global Tuberculosis Report](https://www.who.int/health-topics/tuberculosis).

The `tidyr` package contains a series of tibbles that contain the same set of
information on the number of new cases of tuberculosis (TB) recorded in each of
3 countries in the years 1999 and 2000 as well as the populations of those
countries. Here is the first table.

```{r}
table1
```

Two alternative ways of representing the same information are given in tables
`table2` and `table3`.

```{r}
table2
table3
```

The final representation has the data split across two tables, a scenario that
is actually quite likely given that population data will almost certainly have
been collected separately from the recording of TB cases.

```{r}
table4a
table4b
```

Time series data like this are very commonly represented in this way with a
series of dates or years as columns extending across a spreadsheet. You will
find numerous examples of this if you peruse the various data sets made
available by the UK Office for National Statistics and various other national
and international organizations.

Tables 1 to 4a and 4b are all different representations of the same underlying
data but one of these tables is structured in such a way as to be most readily
used in the tidyverse.

## Data semantics

We've used and discussed the terms 'observation' and 'variable' a number of
times in this course but this would be a good time to consider this once more.
When we talk about an observation, we're talking about a set of values measured
for the same unit or thing, e.g. a person or a date, and when we talk about a
variable we are really talking about the attribute that we are measuring or
recording, e.g. height, temperature or expression value.

**Observations are represented as rows** in our data frames or tibbles, while
the **columns correspond to variables**.

```{block type = "rmdblock"}
From **"Tidy Data"** by **Hadley Wickham**, [*The Journal of Statistical
Software*, vol. 59, 2014](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf).

A data set is a collection of **values**, usually either numbers (if
quantitative) or character strings (if qualitative). Values are organised in
two ways. Every value belongs to a variable and an observation.

A **variable** contains all values that measure the same underlying attribute
(like height, temperature, duration) across units.

An **observation** contains all values measured on the same unit (like a person
or a day) across attributes.
```

## Tidy data rules

A tidy data set is a data frame (or table) for which the following are true:

1. Each **variable** has its own column
2. Each **observation** has its own row
3. Each **value** has its own cell

**Question:** _which of the representations we've just been looking at is tidy?_

Another way of framing the question is to consider what are the variables in the
TB data set, i.e. what are the things that vary and for which we can attach a
value for each observation?

Take another look at tables 4a and 4b. Do each of the columns correspond to a
variable? The country is certainly a variable. In this data set it takes one of
three values: Afghanistan, Brazil or China.

But what about the other two columns, '1999' and '2000'? These are values, not
variables. The variable in this case would be 'year' and could take a value of
1999 or 2000. Tables 4a and 4b are not tidy.

There is also another rather obvious problem with tables 4a and 4b -- the data
are contained in two separate tables. The data would almost certainly have been
collected separately so it's hardly surprising but whenever numbers of people
affected by a disease or engaging in an activity are compared between countries
we almost always want to be comparing the rate (the percentage within the
population) and not the absolute number so that the comparison is fair. We need
to combine the data from these two tables in order to calculate the rate.

The only table that is truly tidy is `table1`. It contains one column for each
of the variables in this data set, namely country, year, the number of new TB
cases and the population. We'll look at tables 2 and 3 shortly and why these
aren't tidy and what we can do about it, but first we'll see how we can convert
tables 4a and 4b into the tidy format.

----

# Pivoting operations

## `pivot_longer()`

The format of tables 4a and 4b is often referred to as 'wide format'. While
neither table looks especially wide, you can imagine that the more WHO data set
contains data for very many years and that if each had its own column the table
would be very much wider.

What we need is a column for 'year' so that we have a count, whether it is the
number of TB cases or the population, for each unique combination of country and
year. Transforming the table in this way is known as 'pivoting' and the `tidyr`
package provides the `pivot_longer()` function for just such an operation.

```{r}
table4a_long <- pivot_longer(table4a, c(`1999`, `2000`), names_to = "year", values_to = "cases")
table4a_long
```

As with almost all tidyverse operations the first argument is the data frame
we're working on. The second specifies which columns we are operating on. Here
we've used a vector with `c()` but it is also quite common and normally more
convenient to use a range of columns, e.g. `` `1999`:`2000` ``. Remember we had
to use backticks because variable names aren't suppose to start with numbers.

The `names_to` and `values_to` arguments are so called because we are taking
the names of the columns we specified (1999 and 2000) and putting these in a new
column given by `names_to` and we are taking the values in each of those columns
and putting these in a a new column given by `values_to`.

We can do the same with `table4b` and join the two resulting tables together to
recreate `table1`.

```{r}
table4b_long <- pivot_longer(table4b, c(`1999`, `2000`), names_to = "year", values_to = "population")
left_join(table4a_long, table4b_long, by = c("country", "year"))
```

## `pivot_wider()`

`pivot_wider()` has the opposite effect of `pivot_longer()` and can be used
to reverse the pivoting operation we just performed on `table4a`.

```{r}
pivot_wider(table4a_long, names_from = "year", values_from = "cases")
```

In some cases the wide format is the more human-readable form and usually it is
a more compact way of representing the data. There is no duplication of the year
value in the wide format of `table4a` and `table4b` for example. We will see
later that this is much more evident with large data matrices, e.g. gene
expression matrices with tens of thousands of genes and tens to thousands of
samples.

Let's look again at `table2`.

```{r}
table2
```

Are the `type` and `count` columns true variables? What is the observational
unit in this case?

If we consider the observational unit to be a country in a specific year then
`table2` is not tidy because observations are split across two rows. Also the
count variable contains counts of what are essentially different things, the
number of cases of TB and the total population.

In tricky situations like this, a tell-tale sign that your data is not in a
tidy format is when you want to visualize your data and you have to perform some
kind of filtering to do so. In this case if we wanted to create a bar plot of
for the population of each country we would have to first remove the rows
corresponding to the number of TB cases.

Similarly, the rate of new TB cases, i.e. the proportion of the population
infected with TB, is something we should be easily able to calculate in a
simple operation but this is actually quite difficult to do so with the data
structured as they are.

We can use `pivot_wider()` to sort this out. The `type` column contains the
variable names so we'd need to set `names_from = "type"`, while the values will
be taken from the `count` column.

```{r}
table2_fixed <- pivot_wider(table2, names_from = "type", values_from = "count")
table2_fixed
```

The resulting table is exactly the same as `table1` and now the rate of
infection can be calculated rather easily.

```{r}
mutate(table2_fixed, rate = cases / population)
```

----

# Splitting columns

Table 3 contains an example of a column that contains multiple values. It is a
somewhat convoluted example but occasionally you may come across data like this.

```{r}
table3
```

The `rate` column contains both the number of TB cases and the population
separated by a '/' character. It is itself a character type and so not
terribly useful for doing anything mathematical with.

## `separate()`

The `separate()` function allows us to split a character column into multiple
columns based on a delimiter or separator.

```{r}
table3_separated <- separate(table3, rate, into = c("cases", "population"), sep = "/")
table3_separated
```

The `sep` argument takes a regular expression that defines how to split the
values. We've mentioned regular expressions before -- they are a language for
search patterns in text used frequently in computer programming and really worth
getting to grips with but sadly these are beyond the scope of this course. In
this case our separator is just the "/" character.

The resulting data frame is still not quite what we want though. This becomes
apparent as soon as we try to do anything with the new `cases` and `population`
columns.

```{r error = TRUE}
mutate(table3_separated, rate = cases / population)
```

By default the separated values are character types. We could convert these
using `mutate_at()`.

```{r}
mutate_at(table3_separated, vars(cases, population), as.integer)
```

But another option is to specify `convert = TRUE` when running `separate()`.

```{r}
table3_separated <- separate(table3, rate, into = c("cases", "population"), sep = "/", convert = TRUE)
mutate(table3_separated, rate = cases / population)
```





