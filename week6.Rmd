---
title: "Week 6 -- Restructuring data for analysis"
---

> #### Learning objectives
>
> * Understand what makes a data set "tidy" and why you'd want your data to be structured this way
> * Use `pivot_longer()` and `pivot_wider()` operations to restructure data frames
> * Tease apart columns containing multiple variables using `separate()`
> * Modify character variables using string manipulation functions from the `stringr` package
> * Customize non-data components of plots created using ggplot2 by changing the theme

---

# Restructuring data

The data you collect or obtain from a third party is not always in a form that
is suitable for exploratory analysis and visualization and may need to be
restructured before you can fully make use of it.

This is particularly true of the plotting and summarizing tools we've been
looking at in this course which are designed specifically to work on data in a
format referred to as 'tidy' data. This is why the tidyverse is so named.

In this session, we will look at what it means for data to be 'tidy' and how
you can transform your data, if necessary, into this form. We'll also look at
useful functions for handling compound variables, that is columns that contain
more than one type of measurement or attribute (you'd be surprised how common
this is) and some of the string manipulation functions from the `stringr`
package that can help with cleaning up values within a data frame.

Finally, we'll take another look at customizing plots created with ggplot2 by
changing various non-data components that are largely cosmetic.

The functions we're mostly focusing on in this session are from the **tidyr**
and **stringr** packages both of which get loaded as part of the tidyverse.

```{r}
library(tidyverse)
```

---

# Tidy data

So what is 'tidy data' and why should we care about it?

To answer these questions, we'll look at different ways in which a simple data
set can be represented and consider the challenges associated with each. The
data set in question is a subset of data from the
[World Health Organization Global Tuberculosis Report](https://www.who.int/health-topics/tuberculosis).

The `tidyr` package contains a series of tibbles that contain the same set of
information on the number of new cases of tuberculosis (TB) recorded in each of
3 countries in the years 1999 and 2000 as well as the populations of those
countries.

Here is the first table, `table1`, that contains a row for every combination of
country and year and separate columns containing the numbers of TB cases and the
population.

```{r}
table1
```

Two alternative ways of representing the same information are given in tables
`table2` and `table3`. We'll consider each of these in turn, shortly.

```{r}
table2
table3
```

The final representation has the data split across two tables, a scenario that
is actually quite likely given that population data will almost certainly have
been collected separately from the recording of TB cases.

```{r}
table4a
table4b
```

Time series data like this are very commonly represented in this way with a
series of dates or years as columns extending across a spreadsheet. You will
find numerous examples of this if you peruse the various data sets made
available by the United Kingdowm Office for National Statistics and various
other national and international organizations.

Tables 1 to 4a and 4b are all different representations of the same underlying
data but one of these tables is structured in such a way as to be most readily
used in the tidyverse.

## Rules for tidy data

```{block type = "rmdblock"}
**Tidy data**

A tidy data set is a data frame (or table) for which the following are true:

1. Each **variable** has its own column
2. Each **observation** has its own row
3. Each **value** has its own cell

See the section on [data semantics](week4.html#data_semantics) for a short recap
on what we mean by observations and variables.
```

**Question:** _which of the above representations of TB cases is tidy?_

Another way of framing the question is to consider what are the variables in the
TB data set, i.e. what are the things that vary and for which we can attach a
value for each observation?

Take another look at tables 4a and 4b. Do each of the columns correspond to a
variable? The country is certainly a variable. In this data set it takes one of
three values: Afghanistan, Brazil or China.

But what about the other two columns, '1999' and '2000'? These are values, not
variables. The variable in this case would be 'year' and could take a value of
1999 or 2000. Tables 4a and 4b are not tidy.

There is also another rather obvious problem with tables 4a and 4b -- the data
are contained in two separate tables. The data would almost certainly have been
collected separately so it's hardly surprising but whenever numbers of people
affected by a disease or engaging in an activity are compared between countries
we almost always want to be comparing the rate (the percentage within the
population) and not the absolute number, so that the comparison is fair. We need
to combine the data from these two tables in order to calculate the rate.

The only table that is truly tidy is `table1`. It contains one column for each
of the variables in the data set, namely country, year, the number of new TB
cases and the population. We'll look at tables 2 and 3 shortly and why these
aren't tidy and what we can do about it, but first we'll see how we can convert
tables 4a and 4b into the tidy format.

----

# Pivoting operations

## `pivot_longer()`

Tables 4a and 4b are examples of what is often referred to as 'wide format'.
While neither table looks especially wide, you can imagine that the more complete
WHO data set contains data for very many years and that if each had its own
column the table would be very much wider.

What we need is a column for 'year' so that we have a count, whether it is the
number of TB cases or the population, for each unique combination of country and
year. Transforming the table in this way is known as 'pivoting' and the `tidyr`
package provides the `pivot_longer()` function for just such an operation.

```{r}
table4a
table4a_long <- pivot_longer(table4a, c(`1999`, `2000`), names_to = "year", values_to = "cases")
table4a_long
```

As with almost all tidyverse operations the first argument is the data frame
we're working on. The second specifies which columns we are operating on. Here
we've used a vector with `c()` but it is also quite customary and normally more
convenient to use a range of columns, e.g. `` `1999`:`2000` ``. Remember that we
have to use backticks because R doesn't like variable names starting with
numbers.

The `names_to` and `values_to` arguments are so called because we are taking
the names of the columns we specified (1999 and 2000) and putting these in a new
column with a name given by `names_to`. Likewise, we are taking values in each
of our specified columns and putting these in a new column whose name is given
by `values_to`.

We can do the same with `table4b` and join the two resulting tables together to
recreate `table1`.

```{r}
table4b_long <- pivot_longer(table4b, c(`1999`, `2000`), names_to = "year", values_to = "population")
left_join(table4a_long, table4b_long, by = c("country", "year"))
```

## `pivot_wider()`

`pivot_wider()` has the opposite effect of `pivot_longer()` and can be used
to reverse the pivoting operation we just performed on `table4a`.

```{r}
pivot_wider(table4a_long, names_from = "year", values_from = "cases")
```

In some cases the wide format is the more human-readable form and usually it is
a more compact way of representing the data. There is no duplication of the year
value in the wide format of `table4a` and `table4b` for example. We will see
later that this is much more evident with large data tables, e.g. gene
expression matrices.

Let's look again at `table2`.

```{r}
table2
```

Are the type and count columns true variables? What is the observational unit in
this case?

If we consider the observational unit to be a country in a specific year then
`table2` is not tidy because observations are split across two rows. Also the
count variable contains counts of what are essentially different things, the
number of cases of TB or the total population.

In tricky situations like this, a tell-tale sign that your data is not in a
tidy format is when you want to visualize your data and you have to perform some
kind of filtering to do so. In this case if we wanted to create a bar plot of
the population of each country we would have to first remove the rows
corresponding to the number of TB cases.

Similarly, the rate of new TB cases, i.e. the proportion of the population
infected with TB, is something we should be calculate easily in a simple
operation. However, this is actually quite difficult to do with the data
structured as they are.

We can use `pivot_wider()` to sort this out. The `type` column contains the
variable names so we'd need to set `names_from = "type"`, while the values will
be taken from the `count` column.

```{r}
table2_fixed <- pivot_wider(table2, names_from = "type", values_from = "count")
table2_fixed
```

The resulting table is exactly the same as `table1` and now the rate of
infection can be calculated rather straightforwardly.

```{r}
mutate(table2_fixed, rate = cases / population)
```

----

# Splitting columns

Table 3 contains an example of a column that contains multiple values. It is a
somewhat convoluted example but occasionally you may come across data like this.

```{r}
table3
```

The `rate` column contains both the number of TB cases and the population
separated by a '/' character. The rate column is a character type so not
terribly useful for doing anything of a mathematical nature in its current
guise.

## `separate()`

The `separate()` function allows us to split a character column into multiple
columns based on a delimiter or separator.

```{r}
table3_separated <- separate(table3, rate, into = c("cases", "population"), sep = "/")
table3_separated
```

The `sep` argument takes a regular expression that defines how to split the
values. We've mentioned regular expressions before -- they are a language for
specifying search patterns used to find sequences of characters within text and
well worth learning. In this case our separator is just the '/' character.

The resulting data frame is still not quite what we want though. This becomes
apparent as soon as we try to do anything with the new `cases` and `population`
columns.

```{r error = TRUE}
mutate(table3_separated, rate = cases / population)
```

By default the separated values are character types. We could convert these
using `mutate_at()`.

```{r}
mutate_at(table3_separated, vars(cases, population), as.integer)
```

But another option is to specify `convert = TRUE` when carrying out the
`separate()` operation, in which case it will deduce the type of the values and
convert the column to be that type.

```{r}
table3_separated <- separate(table3, rate, into = c("cases", "population"), sep = "/", convert = TRUE)
mutate(table3_separated, rate = cases / population)
```

---

# Real example 1: METABRIC gene expression

Although tables 1 to 4a and b contain real data they are, of course, 'toy' data
frames created for demonstration and teaching purposes. We'll now turn our
attention to the METABRIC expression data and see how this needs to be
transformed into a tidier format to open up different avenues for exploring the
data.

We'll first load the table and then select just the columns we're going to need.

```{r message = FALSE}
metabric <- read_csv("data/metabric_clinical_and_expression_data.csv") %>%
  select(Patient_ID, ER_status, ESR1:MLPH)
metabric
```

When we first looked at visualization using ggplot2 we created the following
box plot.

```{r box_plot_1}
ggplot(metabric) +
  geom_boxplot(mapping = aes(x = ER_status, y = GATA3))
```

But what if we would like to create a series of plots using the faceting
functions in ggplot2 with one plot for each gene?

Faceting requires a categorical variable, which is used to divide the data for
each plot. In this case we'd need a gene column, but clearly our data are not
structured in this way.

We have gene names for column headings. Are these variables? Well, maybe,
although a more correct name for each of these variables or column headings
would be 'Expression of ESR1', 'Expression of ERBB2', etc.

But we could consider that these gene column headings are actually values of a
variable called 'gene' or 'gene symbol'. In this regard, what we have is a 'wide
format' table.

Most gene expression matrices have a similar form, although usually there have
rows for each gene and columns for each sample. It should be said that the gene
expression matrix format is a very compact way of representing the data which
could be a consideration when dealing with tens of thousands of genes and
anywhere between a few tens of samples to a few thousand, such is the case for
METABRIC.

Furthermore, there are lots of tools for working with gene expression data in a
matrix format, including many packages in the Bioconductor project. Fortunately,
as we've seen, `pivot_longer()` and `pivot_wider()` provide a convenient means
of converting between tidy and matrix-like formats.

We'll convert our table of ER status and gene expression data to the tidy
format.

```{r}
metabric <- pivot_longer(metabric, ESR1:MLPH, names_to = "Gene", values_to = "Expression")
metabric
```

Note how we specified a range of columns between `ESR1` and `MLPH`. This is
clearly a lot easier than naming each column individually.

We're now in a position to create our faceted box plot chart.

```{r box_plot_2}
ggplot(data = metabric) +
  geom_boxplot(mapping = aes(x = ER_status, y = Expression)) +
  facet_wrap(vars(Gene))
```

The observational unit has changed: the tidy format has
_one-row-per-gene-per-sample_, while wide format was _one-row-per-sample_.
The tidy format is much less compact and involves considerable duplication of
values in the first three columns (`Patient_ID`, `ER_status` and `Gene`).


One of the other plot types we've used in exploring these data was a scatter
plot comparing the expression of two genes across all the samples. For this,
the _one-row-per-sample_ representation is more appropriate and being able to
convert back to this format allows us to create the plot.

```{r scatter_plot_1}
metabric %>%
  pivot_wider(names_from = "Gene", values_from = "Expression") %>%
  ggplot() +
  geom_point(mapping = aes(x = GATA3, y = ESR1, colour = ER_status))
```


